数据库索引 怎么建立，有啥用，为啥要建立
数据库隔离离别 
sql注入问题，
数据库引擎问题
对事物的理解 
什么情况下数据库锁住表 和行
new 和make的区别
指针和普通引用的区别
了解过哪些底层的源码 了解过go 比如map channl 锁 内存管理相关 的哪些实现原理，说一说，简单聊聊说一个你了解过的
怎么让线程有序运行
怎么确保你主线程里面另外跑的三个线程都跑完了
说说你的项目中哪一部分你认为你写的你认为比较好一点的代码，，或者优化过的代码，
slice扩容机制
定时器有了解过吗

索引问题===
 1.索引是什么：加快对表中记录的查找，索引作用于数据表一个列或者多个列
   2.索引怎末建立 ：创建一个普通索引 CREATE INDEX indexName ON mytable(username(length)); 
  3.为啥要建立索引：索引 聚集索引（主键索引  在磁盘中生成的b+树结构 行数据都在叶子上 二分查找查到）  
  非聚集索引 （普通列的索引）（行数据不在叶子节点 查找时候需要找到聚集索引键 再去查数据）
  联合索引（用在多个列上的索引）
  在经常搜索的列  和 经常用到 where 的列 为了增加查询速度，但是索引也会带来一定开销
经常修改表操作不要建立索引 因为修改表 相应的索引也要改）

数据库的事物问题=== 
数据库默认没有开启事物，默认自动提交数据不可以回滚。
数据库事物4大特性 
1原子性：事物不可分割，要么全部成功，要么全部失败
2.一致性：事物从一个一致状态变成另一个一致状态
3.隔离性：数据库每个事物 没有影响，相互隔离
4.持久性，事物一旦提交，对数据库的改变是持久的

事物的隔离级别问题===
事物的隔离级别--多个事物操作数据库的时候，数据库负责隔离操作，以保证各个事物获取数据的准确性
5.数据库可以开启事物隔离级别解决相应问题   如果数据库不考虑隔离性，会引发脏读（读未提交的数据），幻读（读已提交的数据，针对insert语句 删除）
Serializable(串行化)：可避免脏读、不可重复读、虚读情况的发生。
Repeatable read(可重复读)：可避免脏读、不可重复读情况的发生。
Read committed(读已提交)：可避免脏读情况发生。
Read uncommitted(读未提交)：最低级别，以上情况均无法保证。

数据库的表锁 和行锁 问题===
mysql innodb引擎 有行锁（ myisam 那个引擎不支持事务 没有外键 查询速度快 没有行锁 ）多个事物操作同一条数据 除了select  （有索引情况）都会加上行锁 锁住行  ，如果索引失效 行锁会变表锁 锁住表。
索引失效：对于使用了联合索引 查时候 不使用第一部分  like语句 %后，或全表扫 的速度大于索引速度。

sql 注入 问题  判断传参字符串 过滤 一些你你认为危险的注入

new 和make的区别 都是用来给对象在堆上分配内存  mkae只用于 channl map slice的创建 
（初始化 内存不为0） new 给类型分配内存 内存值为0
go 怎么保证主线程运行的线程都跑完  sycn 包 里面的 等待组功能
go 有序运行线程
package main

import (
        "fmt"
)

var c1 chan bool
var c2 chan bool

func f1() {
        fmt.Println(5)
        c1 <- true
}
func f2() {
        <-c1
        fmt.Println(2)
        c2 <- true
}
func f3() {
        <-c2
        fmt.Println(3)
}

func main() {
        c1 = make(chan bool, 0)
        c2 = make(chan bool, 0)
        go f1()
        go f2()
        go f3()
        for {
        }
}
go 定时器 time.NewTimer(2 * time.Second) 返回一个 channel

指针和普通对象：Go的函数调用是值传递，所以如果传对象会进行拷贝.所以一般情况下使用指针，如果要修改参数，则必须使用指针

https://blog.csdn.net/Butterfly_resting/article/details/89668661


https://www.cnblogs.com/gulei/p/6589177.html 微信小程序