java 运行时候数据区？
oom：jvm动态扩展，无法申请到足够内存
stackOverFlow：线程请求栈深度大于jvm所允许的深度

虚拟机栈 （线程私有）每调用一个方法创建一个栈帧，栈帧包括局部变量表，操作数栈，运行时常量池的引用

本地方法栈 （线程私有）

程序计数器 （线程私有） 指向jvm字节码指令位置 唯一不会抛oom地方

方法区（永久代） （程序共享内存）用于存储类信息，常量，静态变量等， 包含运行时常量池存各种符号的引用 
（java8改名为元空间，元空间不在虚拟中，而是使用本地内存）

堆 （程序共享内存） 包含新生代（eden ，from survivor，to survivor）和老年代

java回收新生代内存？
eden ：java新对象创建到这里，大的对象分配到老年代，eden满 处罚MinorGc

from survivor ：放上一次gc幸存者
to  survivor ：把eden里的没清除的对象+from survivor里的对象复制到这，把对象年龄加一
对象的的年龄够了，放老年代，survivor不够了放老年代

java 垃圾回收算法？

引用计数算法 会有循环引用问题
可达性分析解决循环引用
Gc root 和一个对象间没有可达路径，则该对象为不可达，面临回收
标记清楚：把所有需要回收的对象做标记，清除标记对象
复制算法：将内存划分为二块，每次使用一块，内存满，把活得对象复制到另一块去，清除当前内存（对象多，复制算法效率低）
标记整理：标记需要回收的对象，把活着的移到内存一端，清除边界

java 4种引用状态
强引用，把一个对象赋值给一个引用变量 不会被回收
软引用  内存足够不会被回收
弱引用  总会被回收
虚引用

垃圾回收器？