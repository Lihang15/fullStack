java 运行时候数据区？
oom：jvm动态扩展，无法申请到足够内存
stackOverFlow：线程请求栈深度大于jvm所允许的深度

虚拟机栈 （线程私有）每调用一个方法创建一个栈帧，栈帧包括局部变量表，操作数栈，运行时常量池的引用

本地方法栈 （线程私有）

程序计数器 （线程私有） 指向jvm字节码指令位置 唯一不会抛oom地方

方法区（永久代） （程序共享内存）用于存储类信息，常量，静态变量等， 包含运行时常量池存各种符号的引用 
（java8改名为元空间，元空间不在虚拟中，而是使用本地内存）
                                        新生代里对象多次gc都没清掉 放到老年代
堆 （程序共享内存） 包含新生代（8 eden ，1 from survivor， 1 to survivor）和老年代

java回收新生代内存？
eden ：java新对象创建到这里，大的对象分配到老年代，eden满 处罚MinorGc

from survivor ：放上一次gc幸存者
to  survivor ：把eden里的没清除的对象+from survivor里的对象复制到这，把对象年龄加一
对象的的年龄够了，放老年代，survivor不够了放老年代

java 垃圾回收算法？

引用计数算法 会有循环引用问题
可达性分析解决循环引用
Gc root 和一个对象间没有可达路径，则该对象为不可达，面临回收
标记清楚：把所有需要回收的对象做标记，清除标记对象
复制算法：将内存划分为二块，每次使用一块，内存满，把活得对象复制到另一块去，清除当前内存（对象多，复制算法效率低）
标记整理：标记需要回收的对象，把活着的移到内存一端，清除边界

java 4种引用状态
强引用，把一个对象赋值给一个引用变量 不会被回收
软引用  内存足够不会被回收
弱引用  总会被回收
虚引用

垃圾回收器？CMS G1
CMS 垃圾回收器使用多线程标记清除算法 优点：垃圾收集停顿时间短，但是会有内存碎片
CMS 收集过程 出使标记 并发标记 重新标记 并发清除

G1改进了CMS 基于标记整理算法，不产生内存碎片
可以精准的控制垃圾收集停顿时间

full gc触发时机？
1.调用System.gc()
2.老生代内存不足的时候
3.方法区空间不足时

java类加载过程？
加载：会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类各种数据的入口
验证：确保Class文件的字节流包含信息符合jvm要求
准备：在方法区中为类的变量分配空间
解析：虚拟机将常量池的符号引用替换为直接引用
初始化：真正执行类中定义的java程序代码

双亲委派模型？
当收到一个类加载请求，子加载器不会直接加载 而是委托父类加载，父类没加载到，才用子类去加载
好处：不管哪个类加载器加载，都会委托顶层类加载器，保证使用不同类加载器最终得到同一个对象
自定义类加载器（继承 java.lang.ClassLoader）->应用程序类加载器(用户路径上的类)->扩展类加载器(java_home/lib/ext)->启动类加载器（java_home/lib）

spring aop实现原理？ 动态代理+反射
JDK 动态接口代理  通过反射包 proxy 和invocationHander接口实现，invocationHander接口定义横切逻辑，通过反射机制
调用目标类代码，动态将横切逻辑和业务逻辑编织在一起。

spring ioc 好处？
由容器控制对象间的依靠关系,降低类之间的耦合性

springMvc实现原理？
（1）客户端请求提交到DispatchServlet
（2）DispatchServlet 查找 一个或多个HandlerMapping找到处理请求的Controller，将请求提交
（3）Controller逻辑处理后，返回ModelAndView
 （4）DispatchServlet查询到视图解析器，找到ModelAndView指定视图
 （5）视图将结果显示到客户端



threadlocal ？
可以保存线程自己的对象，线程可以可以拿到
使用：ThreadLocal.ThreadLocalMap<ThreadLocal,T> threadLocals = new ThreadLocalMap(); 
 线程.threadLocals.put(this,obj)
 线程.threadLocals.get(this)

redis？
redis的优点：读写性能优异  支持数据持久化 支持事务 数据结构丰富 支持主从复制
redis缺点：1.数据库容量受到物理内存的限制，不能用作海量数据的高性能读写
          2.不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败 需重启
          3. Redis 较难支持在线扩容 在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费
为啥要用redis：高性能：操作内存，远比操作磁盘快
             高并发：直接操作缓存能够承受的请求是远远大于直接访问数据库的
redis为啥快：单线程，不用考虑多线程的切换消耗cpu，不用考虑各种锁的问题
           完全基于内存
           数据结构简单
           异步io
String：设置 ：SET key wanglihang   取得：GET key

List，LPUSH key wanglihang，mutongben   取得LRANGE key 0 10

Hash ：HMSET key name "wanglihang" description "hello"    取得：HGETALL key 

Set，  SADD key redis，mysql      取得 SMEMBERS key

Zset， ZADD key 1 redis
       ZADD key 2 mongodb   取得 ZRANGE key 0 10 WITHSCORES

       EXPIREAT key 1377257300设置key的过期时间
redis 持久化 rdb（默认） aof
rdb：按一定时间 将内存数据写入硬盘，存在dump.rdb文件 融灾性好，数据量大启动时候 比aof效率高
    缺点：持久化过程出现故障 数据丢失
aof：则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据
    优点：通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。
如果两个都配了优先加载AOF

 分布式缓存？
 缓存雪崩？缓存失效，请求直接打到数据库，把数据库打崩
 解决：并发量不多，加锁等待
 为每一个key设置缓存过期
 给缓存数据加标记，如果过期 更新数据

 缓存穿透？ 绕过缓存直接打到数据库
 解决 ：布隆过滤器，把所有可能映射到一个大的哈希表，不存在的数据会被过滤掉
 缓存预热？
 系统上线后将相关的缓存数据直接加载到缓存系统

 缓存降级：缓存服务器挂掉或者缓存失效，时候，不去访问数据库，直接返回默认数据，或者服务内存数据

 如何保证缓存数据和数据库数据一致性？
 删除缓存有两种方式：

先删除缓存，再更新数据库 sleep一会（根据系统定延时多长时间） 再删缓存。解决方案是使用延迟双删。

2.解决方案是消息队列（先更新数据库，成功后往消息队列发消息，消费到消息后再删除缓存，），引入消息队列会带来更多的问题，并不推荐直接使用。

b+树 
存储mysal的索引为啥要用树
因为树的增删改查都快
为什么不用排序二叉树，因为不能保证节点均匀分布，红黑树可以保证节点的均匀分布
因为树的查找性能取决于树的高度

b树 是多路数，可以降低树的高度 m路的b树 最多拥有m个孩子节点 比如说m有三个叉 每个叉最多有三个孩子
文件索引适合b树 因为文件太多不能一次加载到内存，可以给b树的一个节点加载到内存，然后一步一步向下找

b+树 改进了b树 数据都在叶子结点上，同时节点间还加了指针形成链表结构
Hash索引与B+树？
这和业务场景有关。如果只选一个数据，那确实是 Hash 更快。但是数据库中经常会选择多条，这
时候由于 B+ 树索引有序，并且又有链表相连，它的查询效率比 Hash 就快很多了。
而且大量数据不用一次加载到内存，而是加载b+树的节点，一点一点向下找

volatile关键字和synchronized关键字的区别？
     （1）、volatile只能作用于变量，使用范围较小。synchronized可以用在变量、方法、类、同步代码块等，使用范围比较广。
     （2）、volatile只能保证可见性和有序性，不能保证原子性（一个线程改了其他线程立马知道）。而可见性、有序性、原子性synchronized都可以包证。
     （3）、volatile不会造成线程阻塞。synchronized可能会造成线程阻塞。

悲观锁和乐观锁？
悲观锁 每次拿数据都会加锁
乐观锁 不加锁  在更新时候去判断有没有别人改过，可以根据版本号机制实现
一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，
当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，
在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

公平锁（Fair）：加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得
非公平锁（Nonfair）：加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待

ConcurrentHashMap？
ConcurrentHashMap 是有锁的hashmap？ 可以对hashmap加锁 实现线程安全但是锁的粒度太大
ConcurrentHashMap 采用分段锁 粒度小
默认分成 16个 Segment段 一个Segment含一个 HashEntry 数组（组成链表结构）
在put的时候不对整个hashmap加锁会根据hashcode决定把数据put到哪一个Segment段上
每个 Segment 守护一个 HashEntry 数组里的元素,当对 HashEntry 数组的
数据进行修改时，必须首先获得它对应的 Segment 锁。

HashMap？
JDK1.8之前 HashMap由数组＋链表组成的，数组是HashMap的主体，
链表则是主要为了解决hash冲突(两个对象调用的hashCode方法计算的哈希码值一致导致计算的数组索引值相同)而存在的("拉链法"解决冲突 把冲突的对象放链表里)。

JDK1.8以后在解决哈希冲突时有了较大的变化，当链表的长度大于阈值(默认为8）并且当前数组的长度大于64时，
此时此索引位置上的所有数据改为使用红黑树存储。将链表转换成树增加查询速度，如果数组长度不够64则扩容数组，不转树

面试题：哈希表底层采用何种算法计算hash值？还有哪些算法可以计算出哈希值？
底层采用的是key的hashCode方法的值结合数组长度进行无符号右移hash&（length-1）按位与(&)计算出索引。
还可以采用：平方取中法，取余数
（2）面试题：当两个对象的hashCode相等时会怎么样？
会产生哈希碰撞，若key值内容相同则替换旧的value，不然连接到链表后面，链表长度超过阈值8就转换为红黑树存储。
（3）面试题：何时发生哈希碰撞和什么是哈希碰撞，如何解决哈希碰撞？
只要两个元素的key计算的哈希码值相同就会发生哈希碰撞。jdk8前使用链表解决哈希碰撞。jdk8之后使用链表＋红黑树解决哈希碰撞。

hashmap 初始加载容量（16）为什么一定是2的n次方 如果初始容量是10 底层会无符号右移也会变成2的n次方,减少hash碰撞概率
因为在计算插入数据的插入位置时候hash&（length-1） 比如8-1 = 7（二进制0111） 和9-1 = 8(1000)  &运算1 1才是1
  例如 3&(8-1)=3 2&(8-1)=2
3   &(8    - 1)=3  
	00000011  3 hash
&   00000111  7 length-1
    00000011-----》3 数组下标

  例如长度为9时候，3&(9-1)=0 2&(9-1)=0 ，都在0上，碰撞了；

容易算出相同值 hash冲突几率增加，降低hashmap性能

为什么加载因子是0.75 而不是1 或者0.5
当哈希表中的条目数超出了加载因子与当前容量的乘积时也就是16x0.75=12 原数组扩容为32 当前底层数组扩容为当前的2倍
加载因子需要在时间和空间成本上寻求一种折衷。
如果是1 虽然减少了空间开销，提高了空间利用率，但同时也增加了查询时间成本；
如果是0.5，虽然可以减少查询时间成本，但是空间利用率很低，扩容次数增加
可以根据存数据的多少自己控制 初始大小

java1.8 Node<K,V>[] table;在构造函数中直接调用 初始16
java 1.8之前 Entry<K,V>[] table; 在put时候调用


